SWAGOLX.EXE (c) 1993 GDSOFT  ALL RIGHTS RESERVED 00019         INTERRUPT HANDLING ROUTINES                                       1      05-28-9313:48ALL                      SWAG SUPPORT TEAM        BITSTUFF.PAS             IMPORT              40     ÆF‡ {„ Well Percy (or is it Kerry?), I see that the regular crowd here have„ shown you how bit-level thingys work.  So, I'll give you a working„ example, including a Procedure to display the binary notation of any„ Integer, so you can play With the inFormation they've given you. The„ following Program reads & displays info from the equipment list Word„ (Note: I've made [lazy] use of global Variables, do not emulate)...„}„(*******************************************************************)„Program BitsNBytes;                 { ...or Digital Road Kill       }„Uses„  Dos;                              { import Intr() and Registers   }„Var„  NumberFDD,                        { number of floppy drives       }„  InitVMode,                        { intial video mode             }„  COMcount,                         { number of serial ports        }„  LPTcount    : Byte;               { number of Printer ports       }„  Is8087,                           { math copro installed?         }„  IsMouse,                          { pointing device installed?    }„  IsDMA,                            { DMA support installed?        }„  IsGame,                           { game port installed?          }„  IsModem     : Boolean;            { internal modem installed?     }„  EqWord      : Word;               { the equipment list Word       }„  Reg         : Registers;          { to access CPU Registers       }„{-------------------------------------------------------------------}„Function BitSet(AnyWord : Word; BitNum : Byte) : Boolean;„ { return True if bit BitNum of AnyWord is 1, else False if it's 0  }„begin„  BitSet := (BitNum in [0..15]) and ODD(AnyWord SHR BitNum);„end {BitSet};„{-------------------------------------------------------------------}„Procedure WriteBitWord( AnyWord : Word );   { show Word as binary   }„Var„  BinString : String[16];                   { represent binary bits }„  MaxBit,                                   { max number of bits    }„  BitNum    : Byte;                         { bits 0..15            }„begin„  BinString := '0000000000000000';          { default to 0          }„  MaxBit := Length(BinString);              { total bit count (16)  }„  For BitNum := 0 to PRED(MaxBit) do        { process bits (0..15)  }„    if BitSet(AnyWord, BitNum) then„      INC(BinString[MaxBit - BitNum]);„  Write( BinString );                       { Write the binary Form }„end {WriteBitWord};„{-------------------------------------------------------------------}„Procedure ProcessEquipList;     { parse equipment list Word EqWord  }„Var„  BitNum  : Byte;               { to check each bit                 }„  EBitSet : Boolean;            { True if a BitNum is 1, else False }„begin„  For BitNum := 0 to 15 do„  begin                                     { EqWord has 16 bits    }„    EBitSet := BitSet(EqWord,BitNum);       { is this bit set?      }„    Case BitNum of                          { each bit has meaning  }„      0       : if EBitSet then             { if EqWord.0 is set    }„                  NumberFDD := (EqWord SHR 6) and $3 + 1„                else„                  NumberFDD := 0;„      1       : Is8087    := EBitSet; { if math co-pro found  }„      2       : IsMouse   := EBitSet; { if pointing device    }„      3       : ; {reserved, do nothing}„      4       : InitVMode := (EqWord SHR BitNum) and $3;„      5..7    : ; {ignore}„      8       : IsDMA     := EBitSet;„      9       : COMcount  := (EqWord SHR BitNum) and $7;„      10,11   : ; {ignore}„      12      : IsGame    := EBitSet;„      13      : IsModem   := EBitSet;„      14      : LPTcount  := (EqWord SHR BitNum) and $7;„      15      : ; {ignore}„    end; {Case BitNum}„  end; {For BitNum}„end {ProcessEquipList};„{-------------------------------------------------------------------}„Function Maybe(Truth : Boolean) : String;„begin„  if not Truth then„    Maybe := ' not '„  else„    Maybe := ' IS ';„end {Maybe};„{-------------------------------------------------------------------}„begin„  Intr( $11, Reg );„  EqWord := Reg.AX;„  WriteLn;„  Write('Equipment list Word: ',EqWord,' decimal = ');„  WriteBitWord( EqWord );„  WriteLn(' binary');„  WriteLn;„  ProcessEquipList;„  WriteLn('Number of floppies installed: ', NumberFDD );„  WriteLn('Math-coprocessor',Maybe(Is8087),'installed' );„  WriteLn('PS/2 Mouse',Maybe(IsMouse),'installed' );„  Write('Initial video mode: ',InitVMode,' (' );„  Case InitVMode of„    0 : WriteLn('EGA, VGA, PGA)');„    1 : WriteLn('40x25 colour)');„    2 : WriteLn('80x25 colour)');„    3 : WriteLn('80x25 monochrome)');„  end;„  WriteLn('DMA support',Maybe(IsDMA),'installed' );„  WriteLn('Number of COMs installed: ',COMcount );„  WriteLn('Game port',Maybe(IsGame),'installed' );„  WriteLn('IBM Luggable modem',Maybe(IsModem),'installed');„  WriteLn('Number of Printer ports: ',LPTcount );„end {BitsNBytes}.„(*******************************************************************)„„                                                          2      05-28-9313:48ALL                      SWAG SUPPORT TEAM        CLOCK1.PAS               IMPORT              22     ÆFe {„CARLOS BEGUIGNE„}„Program ClockOnScreen;„„{$R-,V-,S-,M 1024, 0, 0„„  ClockOnScreen - Installs resident clock on upper right corner of screen.„„{$IFOPT S+ }„„{„  You must disable stack checking here, since a Runtime error 202 will„  be generated whenever the stack Pointer (as returned by SPtr) is likely„  to drop below 1024.„}„Uses„  Dos, Crt;„Const„  Offset       = $8E;    { Line 1, Column $8E/2 = 71 }„  TimerTick    = $1C;                  { Timer interrupt }„  black        = 0;„  gray         = 7;„  EnvSeg       = $002C;                { Segment of Dos environment }„  ColourSeg    = $B800;                { Segment of colour video RAM }„  MonoSeg      = $B000;                { Segment of monochrome ideo RAM }„  CrtSegment   : Word = ColourSeg;„„Type„  ScreenArray  = Array[0..7] of Record„    number, attribute : Char;„  end;„„  ScreenPtr    = ScreenArray;„„Var„  VideoMode    : Byte Absolute $0000:$0449;„  Screen       : ^ScreenPtr;            { Physical screen address }„  ClockColour  : Char;„  Int1CSave    : Procedure;„„Procedure ShowTime; Interrupt;„Const„  separator    = ':';„Var„  ThisMode     : Byte;„  Time         : LongInt;„  i            : Integer;„  BIOSTicker   : LongInt Absolute $0000:$046C;„„  Procedure DisplayDigit(offset : Integer; digit : Integer);„  begin„    Screen^ [offset].number := Chr(digit div 10+Ord('0'));„    Screen^ [offset+1].number := Chr(digit mod 10+Ord('0'));„  end;  { DisplayDigit }„„begin„  ThisMode := VideoMode;„  if not ((ThisMode = 2) or (ThisMode = 3) or (ThisMode = 7)) Then„    Exit;                              { Do not popup in a Graphic mode }„  For i := 0 to 7 Do„    Screen^[i].attribute := ClockColour;„  Time := (1365*BIOSTicker) div 24852;„  DisplayDigit(0, Time div 3600);      { hours }„  Screen^[2].number := separator;„  Time := Time mod 3600;„  DisplayDigit(3, Time div 60);        { minutes }„  Screen^[5].number := separator;„  DisplayDigit(6, Time mod 60);        { seconds }„  Inline($9C); { PUSHF }„  Int1CSave;„end;  { ShowTime }„„Procedure Release(segment : Word);„InLine(„  $07/                 { POP   ES       ; get segment of block to release }„  $B4/$49/             { MOV   AH, 49h  ; Free Allocated Memory }„  $CD/$21);            { INT   21h      ; call Dos }„„begin  { ClockOnScreen }„  if VideoMode = 7 Then„    CrtSegment := MonoSeg;„  ClockColour := Chr(gray*16+black);      {display video attribute }„  Screen := Ptr(CrtSegment, Offset);„  GetIntVec(TimerTick, @Int1CSave);„  SetIntVec(TimerTick, @ShowTime);„  Release(MemW[PrefixSeg:EnvSeg]);        {Release the environment }„  Keep(0);„  readln;„end.  { ClockOnScreen }„„                                                                  3      05-28-9313:48ALL                      SWAG SUPPORT TEAM        INTREXAM.PAS             IMPORT              7      ÆF% Okay, well, For the most part, calling an interrupt from TP is fairly„simple.  I'll use Interrupt 10h (service 0) as an example:„„Procedure CallInt;„Var„  Regs : Registers;„begin„  Regs.AH := 0;       { Specify service 0 }„  Regs.AL := $13;     { Mode number = 13 hex, MCGA 320x200x256 }„  Intr($10,Regs);     { Call the interrupt }„end;„„This would shift the screen to the MCGA Graphics mode specified.  Now,„it's easier to call this in BAsm (built-in Assembler):„„Procedure CallInt; Assembler;„Asm„  MOV AH,0            { Specify service 0 }„  MOV AL,13h          { Mode number = 13 hex, MCGA 320x200x256 }„  inT 10h             { Call the interrupt }„end;„„                                                                                                            4      05-28-9313:48ALL                      SWAG SUPPORT TEAM        ISRINFO.PAS              IMPORT              6      ÆFªo {„SEAN PALMER„„> Does anyone know how to Write an ISR (interrupt service routine) that will„> continue With the interrupt afterwards. EX: if you Write an ISR that traps„> the mouse Int 33h but let the mouse still operate.„„Try:„}„„Var„  oldMouseHook : Procedure;„„Procedure mouseHook(AX,BX,CX,DX,SI,DI,DS,ES,BP); interrupt;„begin„„ {Your stuff goes here}„ {make sure it doesn't take TOO long!}„„ Asm„   pushF;„ end;          {simulate an interrupt}„„ oldMouseHook; {call old handler}„end;„„{ to install: }„„ getIntVec($33,@oldMouseHook);„ setIntVec($33,@mouseHook);„„{ to deinstall: }„„ setIntVec($33,@oldMouseHook);„„                      5      05-28-9313:48ALL                      SWAG SUPPORT TEAM        REG1.PAS                 IMPORT              6      ÆF „  Registers Demo„„PB>        Procedure GetScreenType (Var SType: Char);„PB>        Var„PB>          Regs: Registers;„PB>        begin„PB>          Regs.AH := $0F;„PB>          Intr($10, Regs);„PB>          if Regs.AL = 7 then„PB>              sType := 'M';        <<<<<„PB>          else„PB>              sType := 'C';„PB>        end;„„   This Procedure would be ideal For a Function...„           Function GetScreenType:Char;„           ...„           if Regs.AL=7 then„              GetScreenType := 'M'„           else„              GetScreenType := 'C';„           ...„                                                                  6      05-31-9308:06ALL                      SWAG SUPPORT TEAM        Critical Error Trap      IMPORT              50     ÆFQc ==============================================================================„ BBS: -=- Edge of the Century -=-„  To: DANIEL KEMPTON               Date: 01-20-93 (05:13)„From: GREG VIGNEAULT             Number: 3196   [140] Pascal„Subj: CRITICAL ERROR HANDLER     Status: Public„------------------------------------------------------------------------------„DK> Can anyone PLEASE give me information on how to write a critical„  > error handler.„„ Below is a quick'n-dirty critical error handler, written without„ any Asm (so is usable from TP v4.0+).  To test it, put a write-„ protected diskette in drive A:, then run the program.  It should„ report error #19 (13 hex, disk write-protected).„„ It'll need to be modified & trimmed to your purpose.  You might„ code your handler to simply ignore errors, then let your main„ program take appropriate action, depending on the error, etc.„„ DOS functions $00..$0C, $30, and $59 should be safe calls from the„ handler.  Function $59 will return the extended error information„ code that you'll need to check (eg. #32 = share violation), as well„ as other data - which you can read up on, in a Dos reference text.„„ I've used one byte of the DOS intra-process communication area (at„ $40:$F0) to return the value needed to tell Dos what to do about„ the error, rather than juggle registers.  This should be okay.„„ This code is cramped, to fit into a single message ...„„{*******************************************************************}„ PROGRAM Example;                       { Critical Error Handler    }„ USES Dos,      { import MsDos, GetIntVec, SetIntVec, Registers     }„      Crt;      { import CheckBreak                                 }„ VAR OldISR     : POINTER;              { to save original ISR ptr  }„     Reg        : Registers;            { to access CPU registers   }„     errNumber  : WORD;                 { extended error code       }„     errClass,                          { error class               }„     errAction,                         { recommended action        }„     errLocus   : BYTE;                 { error locus               }„     FileName   : String[13];           { for ASCIIZ file name      }„{-------------------------------------------------------------------}„ PROCEDURE cErrorISR( AX,BX,CX,DX,SI,DI,DS,ES,BP : WORD); Interrupt;„    BEGIN  { This is it! ...                                        }„    InLine($FB);                        { STI (allow interrupts)    }„    Reg.AX := $3000;  MsDos(Reg);       { fn: get Dos version       }„    IF (Reg.AH < 3) THEN Reg.AL := 3    { if less than Dos 3+ :FAIL }„        ELSE BEGIN                      { else take a closer look.. }„        Reg.AH := $59;  Reg.BX := 0;    { fn: get extended info     }„        MsDos( Reg );                   { call Dos                  }„        errNumber := Reg.AX;            { set|clear error number    }„        errClass := Reg.BH; errAction := Reg.BL; errLocus := Reg.CH;„        WriteLn;  Write( 'Critical error (#', errNumber, ') ' );„        REPEAT WriteLn;                 { loop for user response    }„          Write( 'Abort, Retry, Ignore, Fail (A|R|I|F) ? ',#7);„          Reg.AH := 1;  MsDos(Reg);     { get user input, via Dos   }„        UNTIL UpCase(CHR(Reg.AL)) IN ['A','R','I','F'];„        CASE CHR(Reg.AL) OF             { ... depending on input    }„            'i','I' : Reg.AL := 0;      { = ignore error            }„            'r','R' : Reg.AL := 1;      { = retry the action        }„            'a','A' : Reg.AL := 2;      { = abort                   }„            'f','F' : Reg.AL := 3;      { = fail                    }„            END; {case}„        END; {if Reg.AH}„    Mem[$40:$F0] := Reg.AL;             { to tell Dos what to think }„    InLine( $8B/$E5/                    { mov   sp,bp               }„            $5D/$07/$1F/$5F/$5E/        { pop   bp,es,ds,di,si      }„            $5A/$59/$5B/$58/            { pop   dx,cx,bx,ax         }„            $06/                        { push  es                  }„            $2B/$C0/                    { sub   ax,ax               }„            $8E/$C0/                    { mov   es,ax               }„            $26/$A0/$F0/$04/            { mov   al,es:[4F0h]        }„            $07/                        { pop   es                  }„            $CF);                       { iret                      }„    END {cErrorISR};„{-------------------------------------------------------------------}„ BEGIN  { the main program...                                       }„    CheckBreak := FALSE;                { don't allow Ctrl-Break!   }„    errNumber := 0;                     { clear the error code      }„    GetIntVec( $24, OldISR );           { save current ISR vector   }„    SetIntVec( $24, @cErrorISR );       { set our ISR               }„        {===========================================================}„        { insert your test code here ...                            }„        FileName := 'A:TEST.TXT' + CHR(0);  { ASCIIZ file name      }„        Reg.DS := SEG( FileName );          { file name segment     }„        Reg.DX := OFS( FileName[1] );       { file name offset      }„        Reg.CX := 0;                        { normal attribute      }„        Reg.AH := $3C;                      { fn: create file       }„        MsDos( Reg );                       { via Dos               }„        {===========================================================}„    IF (errNumber <> 0) THEN BEGIN„        Write(#13#10#10,'For error #',errNumber,', user requested ');„        CASE Mem[$40:$F0] OF„            0   : WriteLn('IGNORE');    { just your imagination     }„            1   : WriteLn('RETRY');     { ... endless futility ?    }„            2   : WriteLn('ABORT');     { DOS won't come back here! }„            3   : WriteLn('FAIL');      { call technical support    }„            END; {case}„        END; {if errNumber<>0}„    SetIntVec( $24, OldISR );           { must restore original ISR }„ END.„{*******************************************************************}„„ Greg_„„ Jan.20.1993.Toronto.Canada.        greg.vigneault@bville.gts.org„---„ * Baudeville BBS Toronto CANADA 416-283-0114 2200+ confs„ * PostLink(tm) v1.04  BAUDEVILLE (#1412) : RelayNet(tm)„             7      05-31-9308:08ALL                      GAYLE DAVIS              Int29 Char Capture       IMPORT              22     ÆFQc ==============================================================================„ BBS: -=- Edge of the Century -=-„  To: PERCY WONG                   Date: 03-22-93 (10:19)„From: GAYLE DAVIS                Number: 4475   [140] Pascal„Subj: Capturing Dos Output       Status: Public„------------------------------------------------------------------------------„PW>-> PW>  EXEC(GETENV(COMSPEC),' \C DIR'); { or whatever it is }„PW>-> >can i then capture each line (or even one line) of the Dir output to„„Percy or Kerry ??,„„An elegant  way of accomplishing  your goal  is  to grap INT29.  This is an„UNDOCUMENTED  DOS function,  however, it's  really simple  to use. DOS uses„this to write EVERYTHING to the screen.  The problem is that there is a LOT„of data  output when screen writing  takes place. If you  try to capture to„much you will  need LOTS of memory. However, short  output like your trying„to get is OK.„„Here is some sample code that will let you capture output :„„„{$A+,B-,D+,E+,F-,G+,I+,L+,N-,O-,P-,Q-,R-,S+,T-,V-,X+,Y+}„{$M 4096,0,400000}„„Uses DOS,Crt;„„Type„  ISRRegisters =„    record„      case Byte of„        1 : (BP, ES, DS, DI, SI, DX, CX, BX, AX, IP, CS, Flags : Word);„        2 : (j1,j2,j3,j4,j5 : Word; DL, DH, CL, CH, BL, BH, AL, AH : Byte);„    end;„„CONST„„  OrigInt29 : Pointer = nil;             {Old int 29 vector}„„Var„    grab  : Array[1..32768] Of Char;   { this MAY NOT be enough !!!     }„    idx : LongInt;                     { if output EXCEEDS this, might  }„                                       { lock up machine, so be careful }„    S   : String;„    I   : LongInt;„„{ Here is the MAGIC }„procedure Int29(BP : Word); interrupt;„„var„  Regs : ISRRegisters absolute BP;„„begin„„„ Grab[Idx] := CHAR(Regs.AL);„ Inc(idx);„„ { WILL LOOSE OUTPUT, BUT BETTER THAN LOCKING MACHINE !!}„ If Idx > SizeOf(Grab) THEN Idx := 1;„„ ASM„ PopF„ call OrigInt29„ END;„„end;„„BEGIN„„  GetIntVec($29, OrigInt29);„  SetIntVec($29, @Int29);„„„  Clrscr;„  Idx := 1;„„  {Shell to DOS and run your program}„„  SwapVectors;„  Exec(GetEnv('COMSPEC'), '/c '+ YOURPROGRAM);„  SwapVectors;„„  { GRAB now contains ALL of our output }„„  FOR I := 1 TO Idx DO„      BEGIN„      If Grab[i] = #10 Then BEGIN„                           WriteLn(S);„                           S := ''„                           END ELSE If Grab[i] <> #13 THEN S := S + Grab[i];„„      END;„„  { ABSOLUTELY MUST BE DONE !! }„  if OrigInt29 <> nil then SetIntVec($29, OrigInt29);„„„UtiExprt: To be continued in next message ...„---„ * T.I.F.S.D.B.(from MD,USA 301-990-6362)„ * PostLink(tm) v1.05  TIFSDBU (#1258) : RelayNet(TM)„                                                                       8      08-17-9308:40ALL                      SWAG SUPPORT TEAM        Hooking an interrupt     IMPORT              27     ÆF’˘ PROGRAM CatchInt;„„USES„   Crt,Dos,Printer;„„{This program illustrates how you can modify an„ interrupt service routine to perform special„ services for you.}„„ VAR„    OldInt,OldExitProc: pointer;„    IntCount: array[0..255] of byte;„„ PROCEDURE GoOldInt(OldIntVector: pointer);„ INLINE („    $5B/   {POP BX - Get Segment}„    $58/   {POP AX - Get Offset}„    $89/   {MOV SP,BP}„    $EC/„    $5D/   {POP BP}„    $07/   {POP ES}„    $1F/   {POP DS}„    $5F/   {POP DI}„    $5E/   {POP SI}„    $5A/   {POP DX}„    $59/   {POP CX}„    $87/   {XCHG SP,BP}„    $EC/„    $87/   {XCHG [BP],BX}„    $5E/„    $00/„    $87/   {XCHG [BP+2],AX}„    $46/„    $02/„    $87/   {XCHG SP,BP}„    $EC/„    $CB);  {RETF}„„„ {$F+}„„ PROCEDURE NewExitProc;„„ VAR I: byte;„ VAR A: char;„„ FUNCTION Intr21Desc(IntNbr: byte): string;„„ VAR„    St : string[30];„„ BEGIN„    CASE IntNbr of„       $25: St := 'Set Interrupt Vector';„       $36: St := 'Get Disk Free Space';„       $3C: St := 'Create File with Handle';„       $3E: St := 'Close FILE';„       $40: St := 'WriteFile or Device';„       $41: St := 'Delete FILE';„       $44: St := 'IOCTL';„       $3D: St := 'Open File with Handle';„       $3F: St := 'Read File or Device';„       $42: St := 'Move File pointer';„    ELSE„	St := 'Unknown DOS Service'„    END;„    Intr21Desc := St;„ END;„„„ FUNCTION DecToHex(Deci: byte): string;„„ CONST„    ConvStr: string[16] = '0123456789ABCDEF';„ BEGIN„    DecToHex := ConvStr[Deci div 16 + 1] +„		ConvStr[Deci mod 16 + 1]„ END;„„„ BEGIN„      ClrScr;„      ExitProc := OldExitProc;„      SetIntVec($21,OldInt);„      WriteLn('Int   #   Description');„      WriteLn(' #  Times');„      WriteLn;„      FOR I:= 0 TO 255 DO„	 BEGIN„	    IF IntCount[I] <> 0 THEN„	       BEGIN„		  Write(DecToHex(I),'H');„		  Write(' ',IntCount[I]:3);„		  GotoXY(11,WhereY);„		  WriteLn(Intr21Desc(I))„	       END„	 END„ END;„„„ PROCEDURE NewInt(AX,BX,CX,DX,SI,„		  DI,SD,ES,BP: Word); INTERRUPT;„„ VAR AH: byte;„„ BEGIN„   Sound(1220);Delay(10);NoSound;„   AH := Hi(AX);„   IntCount[AH] := IntCount[AH]+1;„   GoOldInt(OldInt)„ END;„ {$F-}„„{************ Main Program *****************}„„ VAR I: byte;„     F: text;„     TestStr: string[40];„„ BEGIN„„   ClrScr;„„{Install new Exit PROCEDURE}„„   OldExitProc := ExitProc;„   ExitProc := @NewExitProc;„„{Install new Interrupt Vector}„„   GetIntVec($21, OldInt);„   SetIntVec($21, @NewInt);„„{********  Testing Section  ***********}„„   WriteLn('Starting Testing');Delay(1000);„„   FillChar(IntCount,SizeOf(IntCount),#0);„„   FOR I:= 0 TO 255 DO„   WriteLn('Testing 1');    {WriteLn's to screens}„			    {do not use the 21H }„			    {Interrupt		}„„   Write('TYPE anything TO test keyboard: ');„   ReadLn(TestStr);„„   Writeln('Disk Size ',„	    DiskSize(3));	{Uses Service 36H}„„„   Assign (F,'TestFile');„   Rewrite(f);		    {Uses Service 3CH,44H}„„   FOR I:=0 TO 255 DO„   WriteLn(F,'This is only A test'); {Service 40H}„   WriteLn(F,'This is A test too');„   WriteLn(f,'Last test');„„   Close(f);		    {Uses Service 3EH,40H}„„   Assign(F,'TestFile');„   Append(f);	    {Uses Service 3DH,3FH,42H,44H}„   Close(F);		    {Uses Service 3EH,40H}„„   Assign(F,'TestFile');„   Erase(f)			{Uses Service 41H}„ END.„                                                                                                                       9      08-17-9308:44ALL                      CHRIS PRIEDE             Trapping Int21           IMPORT              22     ÆFQc ===========================================================================„ BBS: Canada Remote Systems„Date: 07-15-93 (18:15)             Number: 26295„From: CHRIS PRIEDE                 Refer#: 26227„  To: PIERRE DARMON                 Recvd: NO  „Subj: DOS interrupt handler          Conf: (552) R-TP„---------------------------------------------------------------------------„PD>What additional steps need to be taken for $21? I even tried to remove„PD>the clicking part, which boils down to installing a new handler that just„PD>calls the old one. Still no go. What's wrong?„„PD>My ultimate goal is to trap file opens (function 3Dh), check the SHAREing„PD>mode used (in AL), modify it if necessary, and execute the old handler.„PD>Doesn't sound like a very complicated thing to do but ... I am stuck.„„    Your handler is changing some registers or suffering from some„registers being changed by INT 21. DOS EXEC service trashes everything,„including SS:SP, for example. In my opinion, one can't write a stable„INT 21 handler in Pascal or any other HLL. HLL interrupt handlers are„usable to certain extent, but this is too low level.„„    It can be done in BASM, though. We will declare interrupt handler as„simple procedure with no arguments to avoid entry/exit code TP generates„for interrupt handlers. Our handler will force all files to be opened in„Deny Write mode (modify for your needs).„„„const„  shCompatibility = $00;„  shDenyAll       = $10;„  shDenyWrite     = $20;„  shDenyRead      = $30;„  shDenyNone      = $40;„„procedure NewInt21; assembler;„asm„  cmp   ah, 3Dh         {open file?}„  je    @CheckModeAL„  cmp   ah, 6Ch         {DOS 4.0+ extended open?}„  je    @CheckModeBL    {extended takes mode in BX}„  jmp   @Chain„„@CheckModeAL:„  and   al, 10001111b     {clear sharing mode bits}„  or    al, shDenyWrite   {set to our mode}„  jmp   @Chain„„@CheckModeBL:„  and   bl, 10001111b„  or    bl, shDenyWrite„  jmp   @Chain„„@I21:„  DD      0       {temp. var. for old vector -- must be in code seg.}„„@Chain:„  push  ds„  push  ax„  mov   ax, SEG @Data„  mov   ds, ax„  mov   ax, WORD PTR OldInt21„  mov   WORD PTR cs:[offset @I21], ax„  mov   ax, WORD PTR OldInt21 +2„  mov   WORD PTR cs:[offset @I21 +2], ax„  pop   ax„  pop   ds„  jmp   DWORD PTR cs:[offset @I21]„end;„„„    To try this save old vector in a global variable named OldInt21 and„install this handler as usual. It also traps function 6Ch, DOS 4.0+„extended open/create. Very few programs use it, but why not...„---„ * Faster-Than-Light (FTL) ˛ Atlanta, GA ˛ 404-292-8761/299-3930„ * PostLink(tm) v1.06  FTL (#93) : RelayNet (tm)„                                                                      10     08-27-9320:26ALL                      JONATHAN WRITE           Changing the Int08 Rate  IMPORT              18     ÆF‚÷ {„JONATHAN WRIGHT„„> A/D (analog to digital conversion).  Somehow I need to use the PC„> clock/timer to call my A/D sampling interrupt at various rates from„> several hundred Hz to several thousand Hz.„„> Hook interrupt 1Ch and point it to your interrupt handler.  Use„> a counter in this procedure to count the number of interrupts or„„This will not work correctly.  Using interrupt 1Ch as it is normally set up,„your interrupt routine will only be called 18 times a second (18.2, actually),„so you could get a maximum of 18.2 Hz.  If you wait until a counter in this„interrupt (incremented by 1 each time) reaches 1820, it will take 10 seconds!„It WON'T be 100 Hz.„„In order to hook the timer interrupt at a rate above 18.2 Hz, you'll need to„revector int 08h (which calls int 1Ch anyway).  You'll have to set up a counter„in int 08h which makes sure that the ORIGINAL int 08h routine is still called„18.2 times a second.  The value for this counter will vary, depending on how„fast you set timer channel 0.  The system clock has a maximum resolution of„about 1.19318 Mhz and IRQ0 is normally called 1193180/65536 times per second.„„Here's some code for changing the clock rate (sorry but it's ASM):„}„;*********************„; called by SetClockRate (which is Pascal callable)„„ClkRate PROC NEAR„„  push  ax„  mov   al,36h„  out   43h,al„  pop   ax„  out   40h,al  xchg  ah,al„  out   40h,al„  ret„ClkRate ENDP„„;******************„; call this routine from TP as SetClockRate (Hz : WORD);„SetClockRate PROC FAR„„Rate EQU word ptr [bp+06]„  push  bp„  mov   bp,sp„  cmp   rate,0„  je    SCR01„„  mov   ax,65535„  xor   dx,dx„  mov   bx,rate„  div   bx„  jmp   SCR02„„SCR01:„  xor   ax,ax„„SCR02:„  call  ClkRate„„  mov   sp,bp„  pop   bp„  ret   2„„SetClockRate ENDP„„I pulled these procedures from some OLD code which I may have inadvertenly„screwed up over time, but it looks o.k.„  Actually revectoring int 08h is a bit more complex - you MUST make sure the„old it 08 is called appropriately because it controls a number of system„functions and your PC WILL lock up if it's not called.  I recommend finding a„book to help with that part.„                                  11     08-27-9320:39ALL                      BRYCE OSTENSON           Handling Ctrl-Break      IMPORT              10     ÆF7£ {„BRYCE OSTENSON„„> I am looking for a way to diable the use of the control break and control„> alt delete features.„„BTW: Simple concept...  Here's how it works - When the program begins,„SavedInt23 is assigned to the original C-Break interrupt...  When the„SetCtrlBreak procedure is called with Status equaling false, the C-Break„interrupt is assigned to a CBreakHandler which has no substance...  Thus„when C-Break is called it does nothing.  When SetCtrlBreak is called„with Status equaling false, Interrupt 23h is assigned to the default„C-Break handler.„}„„UNIT TBUtil;„„INTERFACE„„Uses„  Dos;„„Var„  SavedInt23 : Pointer;„  CBreak     : Boolean;„„Procedure SetCtrlBreak(Status : Boolean);„Function  GetCtrlBreak : Boolean;„„IMPLEMENTATION„„Procedure CBreakHandler; INTERRUPT;„Begin„End;„„Procedure SetCtrlBreak(Status : Boolean);„Begin„  If Status then„    SetIntVec($23, SavedInt23);„  Else„    SetIntVec($23, @CBreakHandler);„  CBreak := Status;„End;„„Function GetCtrlBreak : Boolean;„Begin„  GetCtrlBreak := CBreak;„End;„„Begin„  CBreak := True;„  GetIntVec($23, SavedInt23); { Save the Ctrl-Break handler. }„End.„„                           12     11-02-9305:56ALL                      CHRIS LAUTENBACH         Hooking an Interrupt     IMPORT              26     ÆF
‹ {„CHRIS LAUTENBACH„„∫ I understand basically what you're saying - have a TSR/ISR define„∫ Variables Within itself, then have any child processes hook into those„∫ Variables via an interupt inquiry. However, I'm still a bit fuzzy on it.„∫ Could you provide an example, or a better definition?„„    Here's an example of how to hook an interrupt....„}„„Unit ExampleInt;  { Interrupt hooker example }„„{ Written 08/15/93 by Chris Lautenbach.  Released to the public domain.     }„„{ This Unit, when placed in the Uses clause of your main Program, will hook }„{ Dos Interrupt 28h (Dos Idle) which is called by Dos when it isn't busy.   }„{ Under normal circumstances, this will produce a sort of 'multitasking'    }„{ effect when Dos calls it.  Make sure you call the NotBusy Procedure in    }„{ any keyboard wait loops -- or any other loop that continues For a While,  }„{ otherwise Dos will not get a chance to service Int 28h.                   }„„{ In addition to hooking Int28h, it also provides a custom Exit Procedure   }„{ to deactivate the interrupt.  In this manner, this Unit can be totally    }„{ transparent to the Program it is included in -- even if the Program       }„{ terminates With an error, the interrupt is always disconnected.           }„„{ Access to IntStart and IntStop are provided thru the Interface section to }„{ allow disabling of the interrupt -- in Case a Dos shell or similar        }„{ operation is required.                                                    }„„Interface„„Uses„  Dos, Crt;„„Procedure IntStart;                         { Hook interrupt 28h - internal }„Procedure IntStop;                        { Unhook interrupt 28h - internal }„Procedure NotBusy; Inline($CD/$28);           { Call the Dos Idle interrupt }„„Var„  Int28Orig,„  OldExitProc : Pointer;„„Implementation„„Procedure JmpOldISR(OldISR : Pointer);                 { Jump to an old ISR }„Inline ($5B/$58/$87/$5E/$0E/$87/$46/$10/$89/„        $EC/$5D/$07/$1F/$5F/$5E/$5A/$59/$CB);„„{$F+}„Procedure Int28Handler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);interrupt;„begin„  Inline($FA);                                        { Turn interrupts off }„„  { ... your code goes here ... }„„  Inline($FB);                                    { Turn interrupts back on }„  JmpOldIsr(Int28Orig);            { Jump to the original interrupt address }„end;„{$F-}„„Procedure IntStart;„begin„  GetIntVec($28, Int28Orig);                  { Save original Int 28 vector }„  SetIntVec($28, @Int28Handler);       { Install our cool new Int 28 vector }„end;„„{$F+}„Procedure IntStop;„begin„  SetIntVec($28, Int28Orig);                       { Restore Int 28 handler }„end;„„Procedure IntExit;„begin„  ExitProc := OldExitProc;                     { Restore old Exit Procedure }„  IntStop;                                       { Deactivate our interrupt }„end;„{$F-}„„begin„  OldExitProc := ExitProc;                     { Save the current Exit proc }„  ExitProc := @IntExit;                         { Install our new Exit proc }„  IntStart;                                      { Initialize our interrupt }„end.„„                                                                                                  13     11-02-9305:57ALL                      JON JASIUNAS             Writing an ISR           IMPORT              8      ÆFYj {„JON JASIUNAS„„Write you're own ISR, and perform whatever action you want whenever the„user presses the desired key(s).„}„„Var„  OldInt9 : Pointer;  {- To save original int $09 address }„  OldExit : Pointer;  {- To save original Exit proc }„„Procedure TempInt9;  INTERRUPT;„begin„  { Check For keypress }„  { if pressed process and Exit }„  { else call original int $09 to process keystroke }„end; { TempInt9 }„„Procedure CustomExit;  Far;„begin„{-Restore original Exit proc }„  ExitProc := OldExit;„„{-Restore original int $09 }„  SetIntVec($09, OldInt9);„end;    { CustomExit }„„begin„{-Save original Exit proc and install yours }„  OldExit  := ExitProc;„  ExitProc := @CustomExit;„„{-Save original int $09 and install yours }„  GetIntVec($09, OldInt9);„  SetIntVec($09, @TempInt9);„end.„„                                                                                                        14     01-27-9412:09ALL                      DOUGLAS WEBB             Interrupt Jumping        IMPORT              12     ÆFk {„ If you have an interrupt handler and you want to jump to the original„ interrupt handler and NOT return to your handler.„„Call the following procedure with a pointer to the old interrupt handler„(which you'd better have saved :-).„}„„PROCEDURE JumpToInterrupt(oldvector : Pointer);„INLINE(                        { Jump to old Intr from local ISR  }„   $5B/                        { POP  BX IP part of vector     }„   $58/                        { POP  AX CS part of vector     }„   $87/$5E/$0E/                { XCHG BX,[BP+14] switch ofs/bx }„   $87/$46/$10/                { XCHG AX,[BP+16] switch seg/ax }„   $8B/$E5/                    { MOV  SP,BP                    }„   $5D/                        { POP  BP                       }„   $07/                        { POP  ES                       }„   $1F/                        { POP  DS                       }„   $5F/                        { POP  DI                       }„   $5E/                        { POP  SI                       }„   $5A/                        { POP  DX                       }„   $59/                        { POP  CX                       }„   $CB                         { RETF      Jump [ToOldVector]  }„   );                          { to original timer vector      }„{end JumpToInterrupt}„„                                                                                                                          15     01-27-9413:33ALL                      GREG ESTABROOKS          Disable the pause key    IMPORT              38     ÆF‹® { Updated KEYBOARD.SWG on January 27, 1994 }„„UNIT NoPause;		{  Unit to disable the pause key                }„			{  Last Updated  Apr 26/93                      }„			{  Copyright (C) Greg Estabrooks, 1993          }„INTERFACE„{***********************************************************************}„USES DOS;                       { IMPORT SetIntVec,GetIntVec.           }„VAR„     OldExit   :POINTER;        {  To hold pointer to old exit proc     }„     OldInt09  :POINTER;        {  To hold old int 9h handler           }„„PROCEDURE ForgetPauses;„FUNCTION PausePressed :WORD;    { Returns number of times pause was     }„                                { Since last time ForgetPauses was called.}„{***********************************************************************}„IMPLEMENTATION„VAR„     NumPauses :WORD;           {  To hold number of times pause        }„                                {  was pressed. Not Directly accessible }„                                {  by other processes.                  }„PROCEDURE ForgetPauses; ASSEMBLER;„                       {  Routine to Clear Pause counter variable       }„ASM„  Mov NumPauses,0               {  Clear Pause Variable                 }„END;{ForgetPauses}„„FUNCTION PausePressed :WORD; ASSEMBLER;„                      { Function to return number of times pause pressed}„ASM„  Mov AX,NumPauses              {  Load number of pauses into register  }„END;{PausePressed}„„PROCEDURE TrapPause; ASSEMBLER;„ASM„  Push DS„  Push AX„  Push ES„  Mov AX,Seg @Data              {  Allow us to access numpauses.        }„  Mov DS,AX„  Mov AX,$40                    {  Point ES, to bios data area          }„  Mov ES,AX„  Mov AH,ES:[$18]               {  Put keyboard shift flags into AH     }„  And AH,8                      {  Clear all but potential pause flags  }„  Or AH,0                       {  Check for zero                       }„  Jz @NormalKey                 {  If it was zero pause wasn't pressed  }„  Add NumPauses,1               {  Add 1 to number of pauses pressed    }„  Mov AH,ES:[$18]               {  Load Flags again                     }„  And AH,$F7                    {  Clear pause flags                    }„  Mov ES:[$18],AH               {  Load new flags byte back into bios   }„@NormalKey:„  PushF                         {  Push flags onto stack                }„  Call [OldInt09]               {  Call old Int 9h handler              }„@Exit:„  Sti                           {  Allow Interrupts                     }„  Pop ES                        {  Restore registers that were used     }„  Pop AX„  Pop DS„  IRet                          {  Return from interrupt                }„END;{TrapPause}„„{$F+}„PROCEDURE Restore_Pause;„                       {  Routine to restore int 9  and exit pointers   }„BEGIN„  SetIntVec(9,OldInt09);        { Restore Int pointer to old pointer    }„  ExitProc := OldExit;          { Restore Exit Pointer                  }„END;{Restore_Pause}„{$F-}„„PROCEDURE InitTrap;„                   {  Routine to set Int pointers to TrapPause          }„BEGIN„  GetIntVec(9,OldInt09);        {  Get pointer to Old Int 9h            }„  SetIntVec(9,@TrapPause);      {  Point Int 9 to TrapPause             }„  OldExit := ExitProc;          {  Save Old Exit Pointer                }„  ExitProc := @Restore_Pause;   {  Set exit Pointer to new exit         }„END;{InitTrap}„„BEGIN„  InitTrap;		        { Set up New Int 9h Handler             }„END.{***********************************************************************}„PROGRAM ShowNoPause;            { Demo of NoPause Unit. Greg Estabrooks.}„USES CRT,                       { IMPORT Clrscr,KeyPressed,ReadKey.     }„     NoPause;                   { Unit containing Pause routines.       }„VAR„   Misc :WORD;                  { Holds changing number to show the system}„                                { is not paused.                        }„BEGIN„  Clrscr;                       { Clear screen clutter.                 }„  ForgetPauses;                 { Clear the pauses number holder.       }„  Misc := 0;                    { Clear Counter.                        }„  REPEAT                        { Loop Until a key other than Pause is  }„                                { pressed.                              }„    GOTOXY(1,1);                { Always show info at top corner.       }„    Write(Misc:8,'...  You have pressed pause ',PausePressed:3,' times.');„    INC(Misc);                  { Increase counter to show a change.    }„  UNTIL KeyPressed;„END.{ShowNoPause};„{***********************************************************************}„                                                                                                                 16     02-03-9411:04ALL                      SWAG SUPPORT TEAM        How to Grab Interrupts   IMPORT              13     ÆF°ñ Uses Dos;„var„     ExitSave,„     BKDISave,„     BKDIHandler       : Pointer;„     Regs              : Registers;„     Abort             : Boolean;„„{$F+}„procedure NewCntlBreakHandler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);„interrupt;„begin„inline($FA);  { disable interrupts }„              { do nada widda data }      { OR DO ANYTHING YOU WANT }„inline($FB);  { enable interrupts }„Abort := True;         { Use this for (while NOT abort do..) }„end;„„procedure NewBKDIHandler(Flags,CS,IP,AX,BX,CX,DX,SI,DI,DS,ES,BP:Word);„interrupt;„begin„inline($FA);  { disable interrupts }„              { do nada widda data }      { OR DO ANYTHING YOU WANT }„inline($FB);  { enable interrupts }„AX := 0;      {This must remain. An oversight in Turbo Pascal.}„end;„„procedure MyExit;„begin„     ExitProc := ExitSave;„     SetIntVec($1B, BKDISave);„     SetIntVec($24, BKDIHandler);„end;„{$F-}„„„begin„     ExitSave := ExitProc;„     ExitProc := @MyExit;„     Regs.AH := $35;    { Get Cntl-Break Interrupt Vector }„     Regs.AL := $1B;„     Intr($21,Regs);„     BKDISave := Ptr(Regs.ES, Regs.BX);„     SetIntVec($1B, @NewBKDIHandler);„     Regs.AH := $35;    { Get Cntl-Break Handler Interrupt Vector }„     Regs.AL := $23;„     Intr($21,Regs);„     BKDIHandler := Ptr(Regs.ES, Regs.BX);„     SetIntVec($23, @NewCntlBreakHandler);„„     { Do whatever here. When finished, the old interrupt vectors are„       restored in the MyExit procedure }„end.„„                                                                                            17     02-09-9411:50ALL                      TIM MCKAY                Disabling The Ctrl-Alt-D IMPORT              50     ÆF   „unit NonStop;                         {Makes your program UNSTOPPABLE!}„„interface„„ var„   Intr09 : pointer absolute $0000:$0024; {Interrupt $09, keyboard ISR}„   OldIntr09 : pointer;                   {Original Interrupt $09     }„„const„   NoBoot  : boolean = true;              {flag to disable soft boot  }„   NoBreak : boolean = true;              {flag to disable Ctrl-Break }„   NoCtrlC : boolean = true;              {flag to disable Ctrl-C     }„„ procedure InstallNonStopISR;„ procedure NonStopExitProc;„„implementation„„ var„   PreNonStopExitProc : pointer;„„ const„   Installed : boolean = false;„„ procedure NonStopISR; External; {$L NonStop}„„ procedure InstallNonStopISR;„„ begin„  if not Installed then„  begin„   OldIntr09 := Intr09;„   inline($fa);                       {CLI - disable interrupts         }„   Intr09 := @NonStopISR;              {Link NonStop into interrupt chain}„   inline($fb);                       {STI - enable interrupts          }„   PreNonStopExitProc := ExitProc;    {Save old ExitProc                }„   ExitProc := @NonStopExitProc;      {Link in NonStopExitProc          }„   Installed := true;„  end;„ end;„„ procedure NonStopExitProc;„„ begin„  ExitProc := PreNonStopExitProc;      {Point ExitProc to next  }„  inline($fa);                         {CLI - disable interrupts}„  Intr09 := OldIntr09;                 {Restore Original Vector }„  inline($fb);                         {STI - enable interrupts }„ end;„„end.„„*XX3402-000419-090294--72--85-43138-----NONSTOP.OBJ--1-OF--1„U+o+0qtjPbBoPr+iEJBBG6UU++++53FpQa7j623nQqJhMalZQW+UJaJmQqZjPW+n9X8NW-A+„ECblGoYQ0qtjPbBoPr+iEJBBQ6U1+21dH7M0++-cW+A+E84IZUM+-2F-J234a+Q+G++++U2-„3NM4++F1HoF3FNU5+0WW++A-+N8A7U+4HYx0HoxI++RCHo7GFI39++RCHoBIIYl1++ZDH2F7„HZFGA1Y+l7+F+++00YtDHZBIHp-7Ip6++++oW+E+E86-YO0V++6++-tEi+++XhUilUOR+CeE„znM0+Dwq+++iXkOS+0uD-e++Aw0CqDwq7+-M-HA+I6w47+-M5ls4I9V++6v+i+++XhUaWWML„+61Y-61A+5FAt4+mt+ca++-o2mO87VQ+UCE6UAk+R+MwIrI0ulcmt+ca++-o-XnURE9f119Y„0WM++5END0tp3SFVWi+AUCNVVi1aDTek6CMUK+QTnzhM-lw6b0s+l+dI+gENJ+925ZE0m+BI„+QEE-U22l-E4+EH6D3E-l3A4+E52PUM-+gFw-U21m6c5+A2++U6++8c+„***** END OF BLOCK 1 *****„„„{ ------------------------   ASSEMBLER MODULE  --------------------- }„;ASM NONSTOP.PAS„„DATA    SEGMENT WORD PUBLIC„        ASSUME DS:DATA„EXTRN   NoBoot    : BYTE„EXTRN   NoBreak   : BYTE„EXTRN   NoCtrlC   : BYTE„EXTRN   OldIntr09 : DWORD„DATA    ENDS„„CODE    SEGMENT BYTE PUBLIC„        ASSUME CS:CODE„„NonStopISR PROC FAR„           PUBLIC NonStopISR„„        push    ds                     ;This is the initialization code„        push    ax                     ;It will be used only once„        mov     ax, seg DATA           ;To fix up the far jump„        mov     ds, ax                 ;put Global Data Segment in DS„        mov     cs:[JmpCode], 0eah     ;install far jump op code„        push    [OldIntr09]            ;put pointer to old interrupt 09„        pop     cs:Offs                ;in far jump offset„        pop     cs:Segm                ;in far jump segment„        xor     ax,ax                  ;point DS to interrupt vector table„        mov     ds,ax                  ;ie, ds=0„        push    ds:[24h]               ;Put offset of Int 09„        pop     ax                     ;in ax„        add     ax, Entry - NonStopISR ;Adjust past init code„        push    ax„        pop     ds:[24h]               ;revector to regular entry point„        pop     ax„        pop     ds„Entry:„        push    ds„        push    es„        push    ax„        mov     ax, 40h                ;point es„        mov     es, ax                 ;to BIOS data area„        mov     ax, seg DATA           ;point ds„        mov     ds, ax                 ;to data segment„        mov     ah, es:[17h]           ;put keyboard shift flags in ax„        and     ah, 00000100b          ;mask out everything but ctrl flag„        or      ah, 00000000b          ;see if zero„        jz      NormalKey              ;chain on if ctrl not pressed„        in      al, 60h                ;get make/break code„        xor     ah, ah                 ;zero ah„        or      ah, NoBoot             ;Is flag set to disable soft boot?„        jz      CheckBreak             ;No? Go check for break„        mov     ah, es:[17h]           ;get keyboard shift flags„        and     ah, 00001000b          ;mask out all but alt flag„        or      ah, 00000000b          ;is result zero?„        jz      CheckBreak             ;go on to check for break„        cmp     al, 53h                ;is it del make?„        jnz     CheckBreak             ;no, chain on to old int 09„        jmp short TossIt               ;Soft boot attempted - no dice!„CheckBreak:„        xor     ah, ah                 ;zero ah„        or      ah, NoBreak            ;Flag set to disable ctrl-break?„        jz      CheckCtrlC             ;No? Go check for Ctrl-C„        cmp     al, 0E0h               ;is it Break make?„        jnz     CheckCtrlC             ;No? Go check for Ctrl-C„        jmp short TossIt               ;Ctrl-Break attempted - toss it!„CheckCtrlC:„        xor     ah, ah                 ;zero ah„        or      ah, NoCtrlC            ;flag set to disabe ctrl-c?„        jz      NormalKey              ;No? Chain on to old ISR„        cmp     al, 2Eh                ;C pressed?„        jnz     NormalKey              ;No? Chain on to old ISR„TossIt:„        in      al, 61h                ;read keyboard control port„        mov     ah, al„        or      al, 10000000b          ;set the "reset" bit„        out     61h, al                ;send it back to control„        xchg    ah, al                 ;get back control value„        out     61, al                 ;send it out also„        cli„        mov     al, 20h                ;send EOI to the„        out     20h, al                ;interrupt controller„        pop     ax;„        pop     es;„        pop     ds;„        iret                           ;LATER, DUDE!„NormalKey:„        sti                            ;allow interrupts„        pop     ax                     ;cleanup and„        pop     es„        pop     ds„JmpCode db      ?                      ;Far jump to old Int 09„Offs    dw      ?„Segm    dw      ?„„NonStopISR  ENDP„CODE    ENDS„        END     NonStopISR„„      18     05-26-9406:20ALL                      MAYNARD PHILBROOK        Screen Blanker-InterruptsSWAG9405            28     ÆF   {„Via SLMAIL v3.5C  (#2081)„ -=> Quoting Joe Irwin to Maynard Philbrook <=-„ JI> either inline code or assembler that could be compiled to obj and„ JI> linked that would read the keyboard and if a key is not pressed in a„ JI> variable or set amount of time jump to a procedure.  I'm talking about„ JI> a tsr routine and what I have in mind is a tsr dos screensaver.  I've„ JI> been working on this forever and am just not good enough with interupts„ JI> or assembler to do it. I'm using tp 5.5 which does not support the asm„ JI> command but inline(/) only.  Any help would be appreciated.„ JI> Joe Irwin„ JI> -!- FMail 0.92„ JI>  ! Origin: MK Tech BBS-MK Software (513)237-7737 Dayton,OH HST/v32„ JI> (1:110/290)„}„„Uses dos,crt;„„Const Set_Time :Word = 100;      { 0 for no blanking }„Var„Temp,Temp1 : Integer;„C :Char;„Old_Screen :Array[0..1999] of Word;„OLD_INT9, OLD_INT8 :Pointer;„NO_Pressed :Word;      { Counter }„Saved_Flag :Word;       { varifie Flag }„„{$F+}„Procedure New_Int9; Assembler;     { all of this could be done in TASM }„asm     Push   ES;„       Push    DS;„        Push   BX;„        Push   AX;„        Mov    AX, Seg NO_Pressed;„        Mov    DS, AX;„        Mov    AX, Set_TIme;„        Mov    NO_Pressed, AX;„        Mov    AX, Word [Old_INT9];„        Mov     Word ptr CS:@Return, AX;„        Mov    AX, Word [OLD_INT9+2];„        Mov    Word ptr CS:@Return+2, AX;„        Cmp    Word Ptr Saved_Flag, 00;„        Je     @Done;„       Mov     Word ptr Saved_Flag, 00;„        Mov    BX, 3999;„        Mov    AX, $B800;„        Mov    ES, AX;„@loop:„       Mov     AL, byte [OLD_SCREEN+BX];„       Mov     [ES:BX], AL;„        Dec    BX;„        Jnz    @Loop;„        Mov    AL, byte [OLD_SCREEN+BX];„        Mov    [ES:BX], AL;„@Done:„        Pop    AX;„        Pop    BX;„        Pop    DS;„        Pop    ES;„        Jmp  [Dword(@Return)];„@Return:„       DD      0;„End;„„Procedure New_Int8; Assembler;„ASm„       Push    ES;„       Push    DS;„        Push    BX;„        Push    AX;„        Mov    AX, Seg NO_Pressed;„        Mov    DS, AX;„        Mov    AX, Word [Old_INT8];„        Mov     Word ptr @Return, AX;„        Mov    AX, Word [OLD_INT8+2];„        Mov    Word ptr @Return+2, AX;„        Cmp    NO_PRESSED, $00;„        Je     @Done;„        Dec    Word Ptr NO_PRESSED;„        Jnz    @Done;„        Mov    Saved_Flag, $01;„       Mov     AX, $B800;„        Mov    ES, AX;„       Mov     BX, 3999;„@loop:„       Mov     AL, byte ptr [ES:BX];„       Mov     byte  ptr OLD_SCREEN+BX, AL;„        Mov    byte [ES:BX], 0 ;„        Dec    BX;„        Jnz    @Loop;„        Mov    AL, byte ptr [ES:BX];„        Mov    byte ptr OLD_SCREEN+BX, AL;„@DONE:„        Pop    AX;„        Pop    BX;„        Pop    DS;„        Pop    ES;„        Jmp    [Dword(@Return)];„@Return:„       DD      0;„End;„„BEGIN„„   Val(Paramstr(1), Temp, Temp1);„   If Temp1 = 0 Then Set_Time := temp*18;„   NO_PRESSED := Set_Time;„   SAVED_FLAG := 00;„   GetIntVec($08, OLD_INT8);„   GetIntVec($09, OLD_INT9);„   SetIntVec($09, @New_Int9);„   SetIntVec($08, @New_Int8);„„„   While NOT Keypressed DO;„   { process  your program here }„„SetIntVec($08, old_int8);      { to restore it back to normal }„SetIntVec($09, old_int9);„CLrScr;„WriteLn(' Program Writen Bye Maynard A. Phibrook Jr. ');„WriteLn('          1-203-456-2521  (1993)');„„END.„                                                                                                      19     05-26-9411:03ALL                      KEVIN MESS               Interrupt Table          SWAG9405            40     ÆF   {$R-,S+,I+,D+,T+,F-,V+,B-,N-,L+ }„{$M 4096,0,0 }„„program interrupt_table (input,output);„„{„„  A Program that displays all interrupt vectors.„„  Version 1.00 - 03/10/88 - First release„„  Kevin Mess„  PO Box 35„  Boulder City, NV   89005„  Compuserve 71121,3360„„}„„uses„  crt,dos,cursors; { Cursors unit as written by Scott Bussinger }„„const„  bell        = ^G;„„type„  string4     = string [4];„  keyset      = (ESC,PGUP,PGDN,nothing);„  pointer_rec = record„                  case integer of„                    0 : (address         : pointer);„                    1 : (offset, segment : word)„                end; { record }„  screentype  = record„                   position : array [1..4000] of byte;„                   x,y      : byte;„                end; { record }„var„  vector      : array [$00..$FF] of pointer_rec absolute $0000:0000;„  colorscreen : screentype absolute $B800:0000;„  monoscreen  : screentype absolute $B000:0000;„  savedscreen : screentype;„  intnumber   : byte;„  finished    : Boolean;„„{*************************************}„„function hex (decimal : word) : string4;„„   const„      hexdigit  : array [$0..$F] of char = '0123456789ABCDEF';„„   var„      temp    : string4;„„   begin„      temp := '';„      temp := hexdigit [ hi (decimal) div 16 ] +„              hexdigit [ hi (decimal) mod 16 ] +„              hexdigit [ lo (decimal) div 16 ] +„              hexdigit [ lo (decimal) mod 16 ] ;„      hex  := temp„   end;„„{*************************************}„„procedure frame (x1,y1,x2,y2 : byte);„„   const„      upperleft  = #201;„      lowerleft  = #200;„      upperright = #187;„      lowerright = #188;„      horizontal = #205;„      vertical   = #186;„„   var„      i          : byte;„„   begin„      gotoxy (x1-1,y1-1);„      write  (upperleft);„      gotoxy (x2+1,y1-1);„      write  (upperright);„      gotoxy (x1-1,y2+1);„      write  (lowerleft);„      gotoxy (x2+1,y2+1);„      write  (lowerright);„      for i := x1 to x2 do„         begin„            gotoxy (i,y1-1);„            write  (horizontal);„            gotoxy (i,y2+1);„            write  (horizontal)„         end;„      for i := y1 to y2 do„         begin„            gotoxy (x1-1,i);„            write  (vertical);„            gotoxy (x2+1,i);„            write  (vertical)„         end;„   end; { frame }„„„{*************************************}„„procedure display_screen (first_intnumber : byte);„„  var„     x,y,„     last_intnumber,„     intnumber      : byte;„„  begin { display_screen }„     last_intnumber := first_intnumber + $3F;„     x := 5;„     y := 1;„     for intnumber := first_intnumber to last_intnumber do„       with vector [intnumber] do„         begin„           gotoxy (x,y);„           write (copy(hex(intnumber),3,2),hex(segment):6,':',hex(offset));„           inc (y);„           if ((intnumber + 1) mod $10) = 0 then„             if intnumber <> last_intnumber then„                begin„                  inc (x,19);„                  y := 1„                end„         end; { with }„  end; { display_screen }„„„{*************************************}„„„function endkey : keyset;„„   var„     anykey : char;„     exit   : keyset;„„   begin„     repeat„        exit := nothing;„        anykey := readkey;„        if anykey = #0 then„           anykey := readkey;„        case anykey of„           #27 : exit := ESC;„           #73 : exit := PGUP;„           #81 : exit := PGDN;„           else  write (bell);„        end; { case }„     until exit in [ESC,PGUP,PGDN];„     endkey := exit„   end;„„{*************************************}„„procedure int_table (intnumber : byte);„„   begin { int_table }„      if monodisplay then„         savedscreen := monoscreen„      else„         begin„            savedscreen := colorscreen;„            textcolor (white);„            textbackground (blue)„         end;„      savedscreen.x := wherex;„      savedscreen.y := wherey;„      makecursor (nocursor);„      frame  (2,2,79,19);„      window (2,2,79,19);„      clrscr;„      gotoxy (12,18);„      write ('PgUp - Previous Page,  PgDn - Next Page,  Esc to Exit');„      finished  := FALSE;„      repeat„         display_screen (intnumber);„         case endkey of„            PGUP : if intnumber >= $40 then„                      dec (intnumber,$40)„                   else„                      intnumber := $C0;„            PGDN : if intnumber <= $80 then„                      inc (intnumber,$40)„                   else„                      intnumber := $00;„            ESC  : finished := TRUE„         end { case }„      until finished;„      window (1,1,80,25);„      if monodisplay then„         monoscreen := savedscreen„      else„         colorscreen  := savedscreen;„      gotoxy (savedscreen.x,savedscreen.y);„      makecursor (restorecursor)„   end;  { int_table }„„{*************************************}„„„begin { main }„   intnumber := $00;„   int_table (intnumber)„end. { main }„                                                    